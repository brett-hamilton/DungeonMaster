@page "/attackmapdicetest"

@using DungeonMaster.Data
@using DungeonMaster.Pages.Components
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D;
@inject NavigationManager NavigationManager;

<h3>Attack, Map, and Dice Test</h3>
@if (!gameStarted)
{
    <button class="btn btn-primary" @onclick="StartGame">
        Start Game!
    </button>
}

<img id="board" @ref="boardImg" width="1920" height="1080" style="display:none" src="@boardImage" />
<img id="char1" @ref="character1img" width="22" height="22" style="display:none" src="@char1Image" />



Render With Grid:
<input title="Render With Grid"type="checkbox" @onchange="async eventArgs => { await Render((bool)eventArgs.Value); }">
<button @onclick="async eventArgs => { await Render(); }">REDRAW</button>

<div><BECanvas Width="@canvasWidth" Height="@canvasHeight" @ref="_canvasReference"></BECanvas></div>

@if (gameStarted)
{
    @* Character Controls *@
    <div class="row" id="primaryButtonRow">
        @if (gameTurn.WeaponAttackPossible)
        {
            <button class="btn btn-primary" style="margin-right:5px" @onclick="@( click => Target("weaponAttack") )">Attack With Weapon</button>
        }

        @if (gameTurn.MagicAttackPossible)
        {
            <button class="btn btn-primary" style="margin-right:5px" @onclick="@( click => Target("magicAttack") )"> Damage Spell </button>
        }

        @if (gameTurn.MovePossible)
        {
            <button class="btn btn-primary" style="margin-right:5px" @onclick="@( click => Target("move") )"> Move </button>
        }

        @if (gameTurn.MagicHealPossible)
        {
            <button class="btn btn-primary" style="margin-right:5px" @onclick="@( click => Target("magicHeal") )"> HealingSpell </button>
        }
    </div><br />
    <div id="secondaryButtonRow">
        <div class="row" id="targetButtonsRow">
            @if (showTargetButtons)
            {

                foreach (var character in gameTurn.OtherCharactersInOrder)
                {
                    <button class="btn btn-secondary"  style="margin-right:5px" @onclick="@( click => TakeAction(character) )">@character.Name</button>
                }
            }
        </div>
        @if (showMovementButtons)
        {
            <div id="movementButtonsRow">
                <div class="row">
                    <button class="btn btn-secondary col-sm-2" style="margin-right:5px; margin-bottom:5px">Northwest</button>
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">North</button>
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">Northeast</button>
                </div>
                <div class="row">
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">West</button>
                    <button class="btn btn-secondary col-sm-2 disabled" style="margin-right: 5px; margin-bottom: 5px">Direction</button>
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">East</button>
                </div>
                <div class="row">
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">Southwest</button>
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">South</button>
                    <button class="btn btn-secondary col-sm-2" style="margin-right: 5px; margin-bottom: 5px">Southeast</button>
                </div>
            </div>
        }
        

    </div>
    <br />
    <br />

    @*Dice Modal Controls *@
    <DungeonMaster.Pages.Components.DiceModal @ref="DiceModal" pageContainingModal="AttackMapDiceTest"></DungeonMaster.Pages.Components.DiceModal>
    <DungeonMaster.Pages.Components.D20ModifierModal @ref="D20ModifierModal" pageContainingModal="AttackMapDiceTest"></DungeonMaster.Pages.Components.D20ModifierModal>
    <div>
        <button class="btn btn-primary" @onclick="() => DiceModal.OpenModal()"> Roll Dice</button>
        <button class="btn btn-primary" @onclick="() => D20ModifierModal.OpenModal()"> Roll D20 With Advantage/Disadvantage</button>
    </div>

    <br />
    <br />

    @* Combat Log *@
    <div id="gameLog" class="row" style="outline: 1px solid blue; outline-offset: 8px; max-height: 200px; min-height: 200px">
        <div style="border-right: 1px solid blue" class="col-2">
            <button class="btn btn-secondary" @onclick="ClearLog">Clear Log</button>
        </div>
        @* Use overflow-auto and max/min height to force game log to be scrollable and at set size. Based on Microsoft SignalR example. *@
        <div class="col-10 overflow-auto" style="max-height: 200px; min-height: 200px">
            <ul class="list-group" id="gameLog">
                @* Iterate through the list of strings in reverse order, so newest message is at top. *@
                @for (int i = (GameLog.Count - 1); i >= 0; i--)
                {
                    if (i == (GameLog.Count - 1))
                    {
                        <li class="list-group-item list-group-item-primary">@GameLog[i]</li>
                    }

                    else
                    {
                        <li class="list-group-item list-group-item-secondary">@GameLog[i]</li>
                    }
                }

            </ul>
        </div>
    </div>
}


@code {
    /// <summary>
    /// Bool represented if the game has started or not.
    /// </summary>
    private bool gameStarted = false;

    /// <summary>
    /// Width of the canvas.
    /// </summary>
    private long canvasWidth = 1500;

    /// <summary>
    /// Height of the canvas.
    /// </summary>
    private long canvasHeight = 1500;

    /// <summary>
    /// String representing which action the user is requesting to take.
    /// </summary>
    private string actionToTake = null;

    /// <summary>
    /// Bool representing if the target buttons whould be shown or not.
    /// </summary>
    private bool showTargetButtons = false;

    /// <summary>
    /// Bool representing if the movement buttons should be shown or not.
    /// </summary>
    private bool showMovementButtons = false;

    /// <summary>
    /// List of strings of all attacks carried out.
    /// </summary>
    public List<string> GameLog { get; set; } = new List<string>();

    /// <summary>
    /// Hub connection to send and receive messages.
    /// </summary>
    private HubConnection hubConnection;

    /// <summary>
    /// Represents the current state of the game, including the turn.
    /// </summary>
    private Turn gameTurn;

    /// <summary>
    /// Modal that is to be displayed on the page to roll multiple dice.
    /// </summary>
    private DungeonMaster.Pages.Components.DiceModal DiceModal { get; set; }

    /// <summary>
    /// Modal that is to be displayed on the page, to roll a D20 with modifier.
    /// </summary>
    private DungeonMaster.Pages.Components.D20ModifierModal D20ModifierModal { get; set; }

    /// <summary>
    /// Attributes used to represent the game in the canvas.
    /// </summary>
    private Canvas2DContext _context;                               //Blazor version of javascript _context
    protected BECanvasComponent _canvasReference;                   //Canvas reference for actually calling functions against;
    private static long scaleFactor = 15;                         //For smaller maps, this scales every object by this factor.
    private string backgroundColor = "#009900";                     //Sets the background for the entire canvas. Ideally we would draw the background sprites above this.
    private ElementReference boardImg;
    private ElementReference character1img;
    private ElementReference character2img;
    private string boardImage = string.Empty;
    private string char1Image = string.Empty;
    private string char2Image = string.Empty;
    public Boolean gridInput = false;
    public string gridColor = "#FFFFFF";



    /// <summary>
    /// Method to initialize our hub connection used to send and receive messages.
    /// When a message is received, it is added to the game log.
    /// Modified from the Microsoft SignalR Blazor tutorial.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/dungeonmasterhub"))
                .Build();

        // If the messaged received is for this page, add the new message to the game log.
        hubConnection.On<string, string>("MessageReceived", (message, page) =>
        {
            if (page == "AttackMapDiceTest")
            {
                GameLog.Add(message);
                StateHasChanged();
            }
        });

        await hubConnection.StartAsync();
    }

    /// <summary>
    /// Method to clear the game log.
    /// </summary>
    public void ClearLog()
    {
        GameLog = new List<string>();
    }

    /// <summary>
    /// Method to set the action to use for our next set up bottons, also display the correct buttons
    /// depending upon what the user requested.
    /// </summary>
    /// <param name="action">String representing the action to take.</param>
    public void Target(string action)
    {
        if (action.Equals("magicAttack") || action.Equals("weaponAttack") || action.Equals("magicHeal"))
        {
            showTargetButtons = true;
            showMovementButtons = false;
        }

        else if (action.Equals("move"))
        {
            showTargetButtons = false;
            showMovementButtons = true;
        }

        else
        {
            showTargetButtons = false;
            showMovementButtons = false;
        }

        actionToTake = action;

    }

    /// <summary>
    /// Method to take an actoin which is dependent upon what buttons the user clicked.
    /// </summary>
    /// <param name="character">Character being targeted (if any).</param>
    public void TakeAction(Character character)
    {
        string report = null;
        switch (actionToTake)
        {
            case "weaponAttack":
                if (gameTurn.CurrentCharacter.ActiveWeapon.RangedWeapon)
                {
                    report = gameTurn.Game.RangedAttackAttempt(gameTurn.CurrentCharacter, character);
                }
                else
                {
                    report = gameTurn.Game.MeleeAttackAttempt(gameTurn.CurrentCharacter, character);
                }
                break;
            case "magicAttack":
                break;
            case "magicHeal":
                break;
            case "move":
                break;
            default:
                break;
        }

        // Report the output and reset all the buttons.
        GameLog.Add(report);
        showMovementButtons = false;
        showTargetButtons = false;
        actionToTake = null;

        gameTurn.UpdatePossibilities();

        StateHasChanged();
    }

    /// <summary>
    /// Method to start the test game, create the characters, and load them into the game.
    /// The game is then initialized with the first character's turn started.
    /// </summary>
    public void StartGame()
    {
        var game = new Game(35, 35)
        {
            GameName = "Combination Test Game"
        };

        var character = new Character("Jordan", 100, 2, "ranger");
        character.ImageLocation = "/images/char1.png";
        char1Image = character.ImageLocation;
        game.AddCharacter(character, 1, 1);

        character = new Character("Dustin", 100, 2, "fighter");
        character.ImageLocation = "/images/char2.png";
        game.AddCharacter(character, 12, 12);

        character = new Character("Gavin", 100, 2, "fighter");
        character.ImageLocation = "/images/char2.png";
        game.AddCharacter(character, 30, 10);

        boardImage = game.Gameboard.ImageLocation;

        gameStarted = true;

        gameTurn = new Turn(game);

        canvasWidth = game.Gameboard.Columns * scaleFactor;
        canvasHeight = game.Gameboard.Rows * scaleFactor;
    }

    /// <summary>
    /// OVerride. Called after the page loads. Draws the canvas off of the primary process.
    /// </summary>
    /// <param name="firstRender">True if this is initial render, false otherwise.</param>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            StartGame();                                                      //Initialize the game prior to trying to draw it
            this._context = await this._canvasReference.CreateCanvas2DAsync();
            await Render(gridInput);
        }
    }

    // GAME BOARD METHODS
    /// <summary>
    /// Renders graphics.
    /// </summary>
    public async Task Render()
    {
        await Render(gridInput);
    }

    /// <summary>
    /// Backup the rendered board.
    /// </summary>
    /// <param name="scaledRows">Board rows.</param>
    /// <param name="scaledColumns">Board columns.</param>
    protected async Task BackupRenderBoard(double scaledRows, double scaledColumns)
    {
        await this._context.SetFillStyleAsync(backgroundColor);
        await this._context.FillRectAsync(0, 0, scaledColumns, scaledRows);
    }

    /// <summary>
    /// Renders the board with images included.
    /// </summary>
    /// <param name="elementReference">Reference to element.</param>
    /// <param name="scaledRows">Board rows.</param>
    /// <param name="scaledColumns">Board columns.</param>
    /// <param name="scaleFactor">Scale.</param>
    protected async Task RenderBoardWithImage(ElementReference elementReference, double scaledRows, double scaledColumns, double scaleFactor)
    {
        await this._context.DrawImageAsync(boardImg, 0, 0, scaledColumns, scaledRows);
    }

    /// <summary>
    /// Redner the grid to the screen.
    /// </summary>
    /// <param name="grid">True if there is a grid, false otherwise.</param>
    protected async Task Render(Boolean grid)
    {
        base.StateHasChanged();
        gridInput = grid;
        double scaledRows = scaleFactor * gameTurn.Game.Gameboard.Rows;                          //Scale the row count by our scale factor
        double scaledColumns = scaleFactor * gameTurn.Game.Gameboard.Columns;                    //Scale the column count by our scale factor
        await BackupRenderBoard(scaledRows, scaledColumns);
        await RenderBoardWithImage(boardImg, scaledRows, scaledColumns, scaleFactor);

        await this._context.SetStrokeStyleAsync("#FFFFFF");

        for (int i = 0; i < gameTurn.Game.Gameboard.Rows; i++)
        {
            for (int j = 0; j < gameTurn.Game.Gameboard.Columns; j++)
            {
                double scaledRow = i * scaleFactor;
                double scaledColumn = j * scaleFactor;
                Drawable drawable = gameTurn.Game.Gameboard.Drawables[i, j];
                if (drawable != null)
                {
                    char1Image = drawable.ImageLocation;
                    await this._context.SetFillStyleAsync(drawable.BackupColorCode);
                    base.StateHasChanged();
                    await Task.Delay(10);

                    try
                    {
                        await this._context.DrawImageAsync(character1img, scaledColumn, scaledRow, scaleFactor, scaleFactor);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e);
                        await Task.Delay(10);
                        await this._context.FillRectAsync(scaledColumn, scaledRow, scaleFactor, scaleFactor);
                    }
                }
                else
                {
                    if (grid)
                    {
                        await this._context.StrokeRectAsync(scaledColumn, scaledRow, scaleFactor, scaleFactor);
                    }
                }
            }
        }
    }
}
